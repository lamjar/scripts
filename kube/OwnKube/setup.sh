#!/bin/bash

# ===========================================
# OwnKube - Minikube Docker Compose Optimis√©
# Version: 3.5 Ultimate Edition avec Auto-Fix
# Author: LAMJAR
# ===========================================

set -euo pipefail  # Mode strict avec gestion des pipes
trap 'echo -e "${RED}‚ùå Erreur d√©tect√©e. Ligne $LINENO${NC}"' ERR

# Couleurs optimis√©es
readonly RED='\033[0;31m'
readonly GREEN='\033[0;32m'
readonly YELLOW='\033[1;33m'
readonly BLUE='\033[0;34m'
readonly CYAN='\033[0;36m'
readonly MAGENTA='\033[0;35m'
readonly WHITE='\033[1;37m'
readonly NC='\033[0m'

# Configuration des ressources minimales
readonly MIN_MEMORY_MB=2048
readonly MIN_CPU=1
readonly DEFAULT_MEMORY_MB=2048
readonly DEFAULT_CPU=1
readonly CACHE_DIR="${HOME}/.ownkube/cache"

# Ports par d√©faut (seront v√©rifi√©s et ajust√©s si n√©cessaire)
DEFAULT_API_PORT=18443
DEFAULT_HTTP_PORT=18080
DEFAULT_HTTPS_PORT=18443

# Banni√®re OwnKube
show_banner() {
    clear
    echo -e "${CYAN}"
    cat << 'BANNER'
    ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
    ‚ïë                                                              ‚ïë
    ‚ïë     ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ïó    ‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ïó   ‚ñà‚ñà‚ïó‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ïó‚ñà‚ñà‚ïó   ‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó   ‚ïë
    ‚ïë    ‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë    ‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë ‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó  ‚ïë
    ‚ïë    ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë ‚ñà‚ïó ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ñà‚ñà‚ïó ‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù  ‚ïë
    ‚ïë    ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë‚ïö‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ñà‚ñà‚ïó ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó  ‚ïë
    ‚ïë    ‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ïö‚ñà‚ñà‚ñà‚ïî‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïë ‚ïö‚ñà‚ñà‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïó‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù  ‚ïë
    ‚ïë     ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù  ‚ïö‚ïê‚ïê‚ïù‚ïö‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïê‚ïê‚ïù‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù   ‚ïë
    ‚ïë                                                              ‚ïë
    ‚ïë                       by LAMJAR                              ‚ïë
    ‚ïë                                                              ‚ïë
    ‚ïë         üöÄ Kubernetes L√©ger & Optimis√© pour Tous üöÄ         ‚ïë
    ‚ïë                                                              ‚ïë
    ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
BANNER
    echo -e "${NC}"
    echo -e "${GREEN}    Version 3.5 - Ultimate Edition avec Auto-Fix${NC}"
    echo -e "${YELLOW}    Optimis√© pour: 2GB RAM / 1 CPU${NC}\n"
    sleep 2
}

# Cache pour les op√©rations r√©p√©t√©es
init_cache() {
    mkdir -p "$CACHE_DIR"
}

# Fonctions utilitaires optimis√©es
print_info() { echo -e "${BLUE}‚ÑπÔ∏è  $1${NC}"; }
print_success() { echo -e "${GREEN}‚úÖ $1${NC}"; }
print_warning() { echo -e "${YELLOW}‚ö†Ô∏è  $1${NC}"; }
print_error() { echo -e "${RED}‚ùå $1${NC}"; }

print_header() {
    echo -e "\n${CYAN}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê${NC}"
    echo -e "${CYAN}  $1${NC}"
    echo -e "${CYAN}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê${NC}\n"
}

print_step() {
    echo -e "\n${MAGENTA}‚ñ∂ $1${NC}\n"
}

# Fonction am√©lior√©e pour trouver un port libre
find_free_port() {
    local start_port=$1
    local max_attempts=100
    
    for ((i=0; i<$max_attempts; i++)); do
        local test_port=$((start_port + i))
        
        # V√©rifier avec plusieurs m√©thodes
        if ! lsof -Pi :$test_port -sTCP:LISTEN -t >/dev/null 2>&1 && \
           ! ss -tuln 2>/dev/null | grep -q ":$test_port " && \
           ! netstat -tuln 2>/dev/null | grep -q ":$test_port " && \
           ! docker ps 2>/dev/null | grep -q ":$test_port"; then
            echo $test_port
            return 0
        fi
    done
    
    # Si aucun port trouv√©, utiliser un port al√©atoire √©lev√©
    echo $((30000 + RANDOM % 2000))
}

# Fonction pour v√©rifier et corriger les conflits de ports
check_and_fix_ports() {
    print_header "D√©tection Intelligente des Ports"
    
    local ports_changed=false
    
    # V√©rifier le port API
    print_info "V√©rification du port API ($DEFAULT_API_PORT)..."
    if lsof -Pi :$DEFAULT_API_PORT -sTCP:LISTEN -t >/dev/null 2>&1 || \
       ss -tuln 2>/dev/null | grep -q ":$DEFAULT_API_PORT "; then
        print_warning "Port API $DEFAULT_API_PORT occup√©"
        DEFAULT_API_PORT=$(find_free_port 18443)
        print_success "Nouveau port API: $DEFAULT_API_PORT"
        ports_changed=true
    else
        print_success "Port API $DEFAULT_API_PORT disponible"
    fi
    
    # V√©rifier le port HTTP
    print_info "V√©rification du port HTTP ($DEFAULT_HTTP_PORT)..."
    if lsof -Pi :$DEFAULT_HTTP_PORT -sTCP:LISTEN -t >/dev/null 2>&1 || \
       ss -tuln 2>/dev/null | grep -q ":$DEFAULT_HTTP_PORT "; then
        print_warning "Port HTTP $DEFAULT_HTTP_PORT occup√©"
        DEFAULT_HTTP_PORT=$(find_free_port 18080)
        print_success "Nouveau port HTTP: $DEFAULT_HTTP_PORT"
        ports_changed=true
    else
        print_success "Port HTTP $DEFAULT_HTTP_PORT disponible"
    fi
    
    # V√©rifier le port HTTPS  
    print_info "V√©rification du port HTTPS ($DEFAULT_HTTPS_PORT)..."
    if lsof -Pi :$DEFAULT_HTTPS_PORT -sTCP:LISTEN -t >/dev/null 2>&1 || \
       ss -tuln 2>/dev/null | grep -q ":$DEFAULT_HTTPS_PORT "; then
        print_warning "Port HTTPS $DEFAULT_HTTPS_PORT occup√©"
        DEFAULT_HTTPS_PORT=$(find_free_port 18443)
        print_success "Nouveau port HTTPS: $DEFAULT_HTTPS_PORT"
        ports_changed=true
    else
        print_success "Port HTTPS $DEFAULT_HTTPS_PORT disponible"
    fi
    
    if [ "$ports_changed" = true ]; then
        echo ""
        print_warning "Les ports ont √©t√© ajust√©s pour √©viter les conflits"
        echo -e "${YELLOW}Nouveaux ports:${NC}"
        echo -e "  API:   ${GREEN}$DEFAULT_API_PORT${NC}"
        echo -e "  HTTP:  ${GREEN}$DEFAULT_HTTP_PORT${NC}"
        echo -e "  HTTPS: ${GREEN}$DEFAULT_HTTPS_PORT${NC}"
        echo ""
        sleep 2
    fi
}

# Nettoyage des conteneurs existants
cleanup_existing_containers() {
    print_info "V√©rification des conteneurs existants..."
    
    local existing_containers=$(docker ps -aq -f name=ownkube 2>/dev/null)
    existing_containers+=" $(docker ps -aq -f name=minikube 2>/dev/null)"
    
    if [ ! -z "$(echo $existing_containers | tr -d ' ')" ]; then
        print_warning "Conteneurs OwnKube/Minikube trouv√©s"
        echo "Arr√™t et suppression des conteneurs existants..."
        
        for container in $existing_containers; do
            docker stop $container 2>/dev/null || true
            docker rm $container 2>/dev/null || true
        done
        
        print_success "Conteneurs nettoy√©s"
    fi
}

# D√©tection optimis√©e du syst√®me
detect_system() {
    local os_type=$(uname -s)
    local arch=$(uname -m)
    local total_mem_mb=0
    local cpu_count=0
    
    case "$os_type" in
        Linux*)
            total_mem_mb=$(free -m | awk '/^Mem:/{print $2}')
            cpu_count=$(nproc)
            ;;
        Darwin*)
            total_mem_mb=$(($(sysctl -n hw.memsize) / 1048576))
            cpu_count=$(sysctl -n hw.ncpu)
            ;;
        *)
            print_error "Syst√®me non support√©: $os_type"
            exit 1
            ;;
    esac
    
    echo "$total_mem_mb|$cpu_count"
}

# V√©rification des pr√©requis optimis√©e
check_prerequisites() {
    print_header "V√©rification Rapide des Pr√©requis"
    
    local errors=0
    
    # V√©rifications parall√®les avec timeout
    {
        command -v docker &>/dev/null || { print_error "Docker non trouv√©"; ((errors++)); }
    } &
    
    {
        command -v docker-compose &>/dev/null || docker compose version &>/dev/null || { print_error "Docker Compose non trouv√©"; ((errors++)); }
    } &
    
    wait
    
    if [ $errors -gt 0 ]; then
        print_error "Installez les d√©pendances manquantes"
        echo "Docker: https://docs.docker.com/engine/install/"
        echo "Docker Compose: https://docs.docker.com/compose/install/"
        exit 1
    fi
    
    # V√©rification Docker daemon avec timeout
    if ! timeout 5 docker info &>/dev/null; then
        print_error "Docker daemon non accessible"
        echo "D√©marrez Docker: sudo systemctl start docker"
        exit 1
    fi
    
    print_success "Docker: $(docker --version 2>/dev/null | cut -d' ' -f3 | cut -d',' -f1)"
    
    # D√©tection des ressources
    local system_info=$(detect_system)
    local total_mem_mb=${system_info%|*}
    local cpu_count=${system_info#*|}
    
    # Avertissements pour ressources faibles
    if [ "$total_mem_mb" -lt 2048 ]; then
        print_warning "RAM: ${total_mem_mb}MB (2GB minimum requis)"
        print_info "Mode ultra-l√©ger activ√©"
    else
        print_success "RAM: ${total_mem_mb}MB"
    fi
    
    if [ "$cpu_count" -lt 2 ]; then
        print_warning "CPU: ${cpu_count} cores (performance limit√©e)"
    else
        print_success "CPU: ${cpu_count} cores"
    fi
    
    # V√©rification espace disque optimis√©e
    local available_gb=$(df -BG . 2>/dev/null | awk 'NR==2 {gsub(/[^0-9]/,"",$4); print $4}')
    if [ "$available_gb" -lt 10 ]; then
        print_warning "Espace disque: ${available_gb}GB (10GB minimum)"
    else
        print_success "Espace disque: ${available_gb}GB"
    fi
}

# Recherche de subnet optimis√©e avec cache
find_available_subnet_cached() {
    local cache_file="$CACHE_DIR/subnet_cache"
    
    # V√©rifier le cache (5 minutes)
    if [ -f "$cache_file" ] && [ $(($(date +%s) - $(stat -c %Y "$cache_file" 2>/dev/null || echo 0))) -lt 300 ]; then
        cat "$cache_file"
        return 0
    fi
    
    # Recherche optimis√©e de subnet
    local used_subnets=$(docker network ls --format "{{.Name}}" 2>/dev/null | \
        xargs -P4 -I{} docker network inspect {} 2>/dev/null | \
        grep -oP '"Subnet":\s*"\K[^"]+' 2>/dev/null | sort -u)
    
    local subnet=""
    for i in {20..30}; do
        local test="172.${i}.0.0/16"
        if ! echo "$used_subnets" | grep -qF "$test"; then
            subnet="$test|172.${i}.0.1"
            echo "$subnet" > "$cache_file"
            echo "$subnet"
            return 0
        fi
    done
    
    # Fallback
    subnet="10.99.0.0/16|10.99.0.1"
    echo "$subnet" > "$cache_file"
    echo "$subnet"
}

# Configuration rapide avec valeurs par d√©faut
configure_quick() {
    print_header "Configuration Rapide OwnKube"
    
    # V√©rifier et ajuster les ports avant configuration
    check_and_fix_ports
    
    PROJECT_NAME="${1:-ownkube}"
    MEMORY="${2:-$DEFAULT_MEMORY_MB}"
    CPUS="${3:-$DEFAULT_CPU}"
    API_PORT="$DEFAULT_API_PORT"
    HTTP_PORT="$DEFAULT_HTTP_PORT"
    HTTPS_PORT="$DEFAULT_HTTPS_PORT"
    INSTALL_DASHBOARD="${7:-n}"
    INSTALL_INGRESS="${8:-n}"
    
    # Configuration r√©seau automatique
    print_info "Configuration r√©seau automatique..."
    local subnet_info=$(find_available_subnet_cached)
    NETWORK_SUBNET="${subnet_info%|*}"
    NETWORK_GATEWAY="${subnet_info#*|}"
    NETWORK_NAME="${PROJECT_NAME}-net"
    NETWORK_EXTERNAL="false"
    
    print_success "Configuration optimale d√©finie"
}

# Configuration interactive optimis√©e
configure_interactive() {
    print_header "Configuration Interactive OwnKube"
    
    # V√©rifier et ajuster les ports avant configuration
    check_and_fix_ports
    
    echo -e "${CYAN}Appuyez sur Entr√©e pour les valeurs par d√©faut${NC}\n"
    
    read -rp "Nom du projet [ownkube]: " PROJECT_NAME
    PROJECT_NAME=${PROJECT_NAME:-ownkube}
    
    read -rp "RAM en MB [2048]: " MEMORY
    MEMORY=${MEMORY:-2048}
    
    read -rp "Nombre de CPUs [1]: " CPUS
    CPUS=${CPUS:-1}
    
    # Proposer les ports d√©tect√©s automatiquement
    read -rp "Port API [$DEFAULT_API_PORT]: " API_PORT
    API_PORT=${API_PORT:-$DEFAULT_API_PORT}
    
    read -rp "Port HTTP [$DEFAULT_HTTP_PORT]: " HTTP_PORT
    HTTP_PORT=${HTTP_PORT:-$DEFAULT_HTTP_PORT}
    
    read -rp "Port HTTPS [$DEFAULT_HTTPS_PORT]: " HTTPS_PORT
    HTTPS_PORT=${HTTPS_PORT:-$DEFAULT_HTTPS_PORT}
    
    # R√©seau automatique pour simplicit√©
    print_info "Configuration r√©seau automatique..."
    local subnet_info=$(find_available_subnet_cached)
    NETWORK_SUBNET="${subnet_info%|*}"
    NETWORK_GATEWAY="${subnet_info#*|}"
    NETWORK_NAME="${PROJECT_NAME}-net"
    NETWORK_EXTERNAL="false"
    
    read -rp "Dashboard Kubernetes? (o/n) [n]: " INSTALL_DASHBOARD
    INSTALL_DASHBOARD=${INSTALL_DASHBOARD:-n}
    
    read -rp "Ingress Controller? (o/n) [n]: " INSTALL_INGRESS
    INSTALL_INGRESS=${INSTALL_INGRESS:-n}
    
    print_success "Configuration enregistr√©e"
}

# Cr√©ation de structure optimis√©e
create_directory_structure() {
    print_header "Cr√©ation Structure OwnKube"
    
    mkdir -p "$PROJECT_NAME"/{projects,manifests/examples,scripts,kube-config,data/{minikube,docker}} 2>/dev/null || true
    cd "$PROJECT_NAME"
    
    print_success "Structure cr√©√©e: $(pwd)"
}

# Docker Compose optimis√© SANS l'attribut version
create_docker_compose() {
    print_header "Cr√©ation Docker Compose Optimis√©"
    
    # IMPORTANT: Pas d'attribut "version" pour √©viter le warning
    cat > docker-compose.yml << 'EOF'
services:
  ownkube:
    image: ${MINIKUBE_IMAGE:-kicbase/stable:v0.0.42}
    container_name: ${CONTAINER_NAME:-ownkube}
    hostname: ownkube
    privileged: true
    restart: unless-stopped
    
    environment:
      - MINIKUBE_IN_STYLE=false
      - CHANGE_MINIKUBE_NONE_USER=true
      - KUBECONFIG=/etc/kubernetes/admin.conf
    
    ports:
      - "${K8S_API_PORT:-18443}:8443"
      - "${HTTP_PORT:-18080}:80"
      - "${HTTPS_PORT:-18443}:443"
      - "${NODEPORT_START:-30000}-${NODEPORT_END:-30010}:30000-30010"
    
    volumes:
      - minikube-data:/var
      - docker-data:/var/lib/docker
      - ./manifests:/manifests:ro
      - ./kube-config:/root/.kube
    
    networks:
      - ownkube-net
    
    deploy:
      resources:
        limits:
          cpus: '${CPU_LIMIT:-1}'
          memory: ${MEMORY_LIMIT:-2048M}
        reservations:
          cpus: '${CPU_RESERVATION:-0.5}'
          memory: ${MEMORY_RESERVATION:-1024M}
    
    command: >
      sh -c "
      dockerd-entrypoint.sh &
      sleep 5 &&
      minikube start 
        --driver=docker 
        --container-runtime=docker
        --cpus=${MINIKUBE_CPUS:-1}
        --memory=${MINIKUBE_MEMORY:-1800}
        --disk-size=${DISK_SIZE:-10g}
        --cache-images=false
        --preload=false
        --apiserver-ips=0.0.0.0
        --listen-address=0.0.0.0
        --extra-config=kubelet.max-pods=30
        --extra-config=kubelet.pods-per-core=5
        --extra-config=apiserver.service-node-port-range=30000-30010 &&
      tail -f /dev/null
      "
    
    healthcheck:
      test: ["CMD", "minikube", "status", "--format", "{{.Host}}"]
      interval: 60s
      timeout: 10s
      retries: 3
      start_period: 90s

networks:
  ownkube-net:
    driver: bridge
    driver_opts:
      com.docker.network.bridge.enable_icc: "true"
      com.docker.network.bridge.enable_ip_masquerade: "true"
    ipam:
      config:
        - subnet: ${NETWORK_SUBNET:-172.20.0.0/16}

volumes:
  minikube-data:
    driver: local
  docker-data:
    driver: local
EOF
    
    print_success "Docker Compose optimis√© cr√©√© (sans attribut version)"
}

# Fichier .env optimis√©
create_env_file() {
    print_header "Cr√©ation Configuration Environnement"
    
    cat > .env << EOF
# OwnKube Configuration - by LAMJAR
CONTAINER_NAME=ownkube
MINIKUBE_IMAGE=kicbase/stable:v0.0.42

# Ressources Optimis√©es
MINIKUBE_CPUS=$CPUS
MINIKUBE_MEMORY=$((MEMORY * 9 / 10))
DISK_SIZE=10g
CPU_LIMIT=${CPUS}
CPU_RESERVATION=0.5
MEMORY_LIMIT=${MEMORY}M
MEMORY_RESERVATION=$((MEMORY / 2))M

# Ports (Auto-d√©tect√©s pour √©viter les conflits)
K8S_API_PORT=$API_PORT
HTTP_PORT=$HTTP_PORT
HTTPS_PORT=$HTTPS_PORT
NODEPORT_START=30000
NODEPORT_END=30010

# R√©seau
NETWORK_SUBNET=$NETWORK_SUBNET
NETWORK_GATEWAY=$NETWORK_GATEWAY
EOF
    
    print_success "Configuration environnement cr√©√©e"
}

# Scripts de gestion optimis√©s avec gestion des erreurs
create_utility_scripts() {
    print_header "Cr√©ation Scripts de Gestion"
    
    # Script principal de gestion avec fix int√©gr√©
    cat > ownkube.sh << 'SCRIPT'
#!/bin/bash
# OwnKube Management Script with Auto-Fix

GREEN='\033[0;32m'
RED='\033[0;31m'
CYAN='\033[0;36m'
YELLOW='\033[1;33m'
NC='\033[0m'

show_logo() {
    echo -e "${CYAN}"
    echo "  ___                 _  __      _          "
    echo " / _ \__      ___ __ | |/ /   _ | |__   ___ "
    echo "| | | \ \ /\ / / '_ \| ' / | | | '_ \ / _ \\"
    echo "| |_| |\ V  V /| | | | . \ |_| | |_) |  __/"
    echo " \___/  \_/\_/ |_| |_|_|\_\__,_|_.__/ \___|"
    echo "                              by LAMJAR"
    echo -e "${NC}\n"
}

# Fonction pour v√©rifier et corriger les probl√®mes
fix_issues() {
    # Supprimer l'attribut version si pr√©sent
    if [ -f "docker-compose.yml" ] && grep -q "^version:" docker-compose.yml; then
        echo -e "${YELLOW}Correction: Suppression de l'attribut version obsol√®te${NC}"
        sed -i '/^version:/d' docker-compose.yml
    fi
    
    # V√©rifier les conflits de ports
    if [ -f ".env" ]; then
        source .env
        for port in $K8S_API_PORT $HTTP_PORT $HTTPS_PORT; do
            if lsof -Pi :$port -sTCP:LISTEN -t >/dev/null 2>&1; then
                echo -e "${YELLOW}‚ö†Ô∏è  Port $port en conflit, arr√™t des conteneurs existants...${NC}"
                docker stop ownkube 2>/dev/null || true
                docker rm ownkube 2>/dev/null || true
                break
            fi
        done
    fi
}

case "$1" in
    start)
        show_logo
        fix_issues  # Auto-fix avant d√©marrage
        echo -e "${GREEN}üöÄ D√©marrage OwnKube...${NC}"
        docker-compose up -d
        if [ $? -eq 0 ]; then
            echo -e "${GREEN}‚úÖ OwnKube d√©marr√© avec succ√®s${NC}"
            echo -e "${CYAN}Acc√®s: https://localhost:$(grep K8S_API_PORT .env | cut -d= -f2)${NC}"
        else
            echo -e "${RED}‚ùå Erreur au d√©marrage. V√©rifiez: docker-compose logs${NC}"
        fi
        ;;
    stop)
        echo -e "${RED}‚èπÔ∏è  Arr√™t OwnKube...${NC}"
        docker-compose down
        ;;
    restart)
        $0 stop
        sleep 2
        $0 start
        ;;
    status)
        docker exec ownkube minikube status 2>/dev/null || echo "OwnKube arr√™t√©"
        ;;
    logs)
        docker-compose logs -f --tail=100
        ;;
    shell)
        docker exec -it ownkube /bin/bash
        ;;
    kubectl|k)
        shift
        docker exec -it ownkube kubectl "$@"
        ;;
    deploy)
        [ -z "$2" ] && { echo "Usage: $0 deploy <file.yaml>"; exit 1; }
        docker exec ownkube kubectl apply -f "/manifests/$2"
        ;;
    fix)
        echo -e "${YELLOW}üîß Correction des probl√®mes...${NC}"
        fix_issues
        # Red√©marrer si n√©cessaire
        if docker ps | grep -q ownkube; then
            $0 restart
        fi
        echo -e "${GREEN}‚úÖ Corrections appliqu√©es${NC}"
        ;;
    clean)
        echo -e "${RED}üßπ Nettoyage complet...${NC}"
        docker-compose down -v
        rm -rf data/*
        ;;
    info)
        show_logo
        echo -e "${CYAN}√âtat:${NC}"
        $0 status
        echo -e "\n${CYAN}Ports configur√©s:${NC}"
        grep -E "K8S_API_PORT|HTTP_PORT|HTTPS_PORT" .env 2>/dev/null || echo "Config non trouv√©e"
        echo -e "\n${CYAN}Ressources:${NC}"
        docker stats --no-stream ownkube 2>/dev/null || echo "Conteneur arr√™t√©"
        echo -e "\n${CYAN}Pods:${NC}"
        docker exec ownkube kubectl get pods -A 2>/dev/null || echo "Kubernetes non disponible"
        ;;
    *)
        show_logo
        echo "Usage: $0 {start|stop|restart|status|logs|shell|kubectl|deploy|fix|clean|info}"
        echo ""
        echo "  start   - D√©marrer OwnKube (avec auto-fix)"
        echo "  stop    - Arr√™ter OwnKube"
        echo "  restart - Red√©marrer OwnKube"
        echo "  status  - √âtat du cluster"
        echo "  logs    - Afficher les logs"
        echo "  shell   - Shell dans le conteneur"
        echo "  kubectl - Ex√©cuter kubectl (alias: k)"
        echo "  deploy  - D√©ployer un manifest"
        echo "  fix     - Corriger les probl√®mes"
        echo "  clean   - Nettoyer tout"
        echo "  info    - Informations compl√®tes"
        ;;
esac
SCRIPT
    
    chmod +x ownkube.sh
    
    # Script de monitoring l√©ger
    cat > monitor.sh << 'MONITOR'
#!/bin/bash
# OwnKube Monitor

while true; do
    clear
    echo "=== OwnKube Monitor ==="
    echo "$(date)"
    echo ""
    echo "CPU & Memory:"
    docker stats --no-stream ownkube 2>/dev/null | tail -n +2
    echo ""
    echo "Cluster Status:"
    docker exec ownkube minikube status 2>/dev/null || echo "Offline"
    echo ""
    echo "Pods Running:"
    docker exec ownkube kubectl get pods -A 2>/dev/null | grep Running | wc -l
    echo ""
    echo "Press Ctrl+C to exit"
    sleep 5
done
MONITOR
    
    chmod +x monitor.sh
    
    # Script de diagnostic des ports
    cat > check-ports.sh << 'PORTCHECK'
#!/bin/bash
# Script de v√©rification des ports OwnKube

source .env 2>/dev/null

echo "=== V√©rification des Ports OwnKube ==="
echo ""

check_port() {
    local port=$1
    local name=$2
    echo -n "$name (Port $port): "
    if lsof -Pi :$port -sTCP:LISTEN -t >/dev/null 2>&1; then
        echo "‚ùå OCCUP√â"
        lsof -i :$port | grep LISTEN
        return 1
    else
        echo "‚úÖ Disponible"
        return 0
    fi
}

check_port ${K8S_API_PORT:-18443} "API Kubernetes"
check_port ${HTTP_PORT:-18080} "HTTP"
check_port ${HTTPS_PORT:-18443} "HTTPS"

echo ""
echo "Si des ports sont occup√©s, utilisez: ./ownkube.sh fix"
PORTCHECK
    
    chmod +x check-ports.sh
    
    print_success "Scripts de gestion cr√©√©s avec auto-fix int√©gr√©"
}

# Manifest exemple optimis√©
create_example_manifest() {
    print_header "Cr√©ation Exemples Kubernetes"
    
    cat > manifests/examples/hello-world.yaml << 'EOF'
apiVersion: v1
kind: Pod
metadata:
  name: hello-ownkube
  labels:
    app: hello
spec:
  containers:
  - name: hello
    image: busybox:latest
    command: ['sh', '-c', 'echo "OwnKube by LAMJAR is running!" && sleep 3600']
    resources:
      requests:
        memory: "32Mi"
        cpu: "50m"
      limits:
        memory: "64Mi"
        cpu: "100m"
---
apiVersion: v1
kind: Service
metadata:
  name: hello-service
spec:
  type: NodePort
  ports:
    - port: 80
      targetPort: 80
      nodePort: 30001
  selector:
    app: hello
EOF
    
    print_success "Exemples cr√©√©s"
}

# README optimis√©
create_readme() {
    cat > README.md << 'README'
# üöÄ OwnKube by LAMJAR

## Installation Kubernetes Ultra-L√©g√®re avec Auto-Fix

### ‚ö° D√©marrage Rapide
```bash
./ownkube.sh start     # D√©marrer OwnKube (auto-fix inclus)
./ownkube.sh info      # Voir l'√©tat complet
./ownkube.sh k get pods -A  # Lister les pods
```

### üîß R√©solution Automatique des Probl√®mes
OwnKube d√©tecte et corrige automatiquement:
- Conflits de ports
- Attribut version obsol√®te dans docker-compose
- Conteneurs en conflit

### üéØ Commandes Essentielles
| Commande | Description |
|----------|-------------|
| `./ownkube.sh start` | D√©marrer le cluster (avec auto-fix) |
| `./ownkube.sh stop` | Arr√™ter le cluster |
| `./ownkube.sh restart` | Red√©marrer le cluster |
| `./ownkube.sh status` | √âtat du cluster |
| `./ownkube.sh shell` | Shell dans le conteneur |
| `./ownkube.sh k <cmd>` | Ex√©cuter kubectl |
| `./ownkube.sh deploy <file>` | D√©ployer un manifest |
| `./ownkube.sh fix` | Corriger les probl√®mes manuellement |
| `./check-ports.sh` | V√©rifier les ports |

### üí° Optimis√© Pour
- **RAM**: 2GB minimum
- **CPU**: 1 core minimum  
- **Disque**: 10GB minimum
- **Ports**: D√©tection automatique des ports libres

### üìä Monitoring
```bash
./monitor.sh    # Surveillance en temps r√©el
```

### üöÄ Exemple de D√©ploiement
```bash
./ownkube.sh deploy examples/hello-world.yaml
./ownkube.sh k get pods
```

### üåê Acc√®s Services
Les ports sont automatiquement configur√©s pour √©viter les conflits.
V√©rifiez vos ports avec: `./ownkube.sh info`

### üõ†Ô∏è D√©pannage
Si vous rencontrez des probl√®mes:
```bash
./check-ports.sh    # V√©rifier les ports
./ownkube.sh fix    # Appliquer les corrections
./ownkube.sh logs   # Voir les logs
```

---
*OwnKube - Kubernetes intelligent et auto-r√©parant*
README
    
    print_success "Documentation cr√©√©e"
}

# T√©l√©chargement optimis√© des images
pull_docker_images() {
    print_header "Pr√©paration des Images Docker"
    
    print_info "T√©l√©chargement image Minikube optimis√©e..."
    docker pull kicbase/stable:v0.0.42 --quiet &
    
    local pull_pid=$!
    local spinner=('‚†ã' '‚†ô' '‚†π' '‚†∏' '‚†º' '‚†¥' '‚†¶' '‚†ß' '‚†á' '‚†è')
    
    while kill -0 $pull_pid 2>/dev/null; do
        for s in "${spinner[@]}"; do
            printf "\r${CYAN}%s${NC} T√©l√©chargement en cours..." "$s"
            sleep 0.1
        done
    done
    
    wait $pull_pid
    printf "\r"
    print_success "Images Docker pr√™tes"
}

# D√©marrage optimis√© avec gestion d'erreurs
start_ownkube() {
    print_header "Lancement OwnKube"
    
    # Nettoyer les conteneurs existants si n√©cessaire
    cleanup_existing_containers
    
    # D√©marrer avec docker-compose
    docker-compose up -d 2>/dev/null
    
    if [ $? -ne 0 ]; then
        print_warning "Premier d√©marrage √©chou√©, tentative de correction..."
        
        # Essayer de trouver de nouveaux ports
        check_and_fix_ports
        
        # Recr√©er le fichier .env avec les nouveaux ports
        create_env_file
        
        # R√©essayer
        docker-compose up -d
        
        if [ $? -ne 0 ]; then
            print_error "Impossible de d√©marrer OwnKube"
            docker-compose logs --tail=20
            return 1
        fi
    fi
    
    print_info "Initialisation du cluster (60-90 secondes)..."
    
    local max_attempts=30
    local attempt=0
    
    while [ $attempt -lt $max_attempts ]; do
        if docker exec ownkube minikube status --format "{{.Host}}" 2>/dev/null | grep -q "Running"; then
            print_success "OwnKube op√©rationnel!"
            return 0
        fi
        printf "\r${CYAN}‚è≥${NC} Attente... %d/%d" $((attempt+1)) $max_attempts
        sleep 3
        ((attempt++))
    done
    
    print_warning "D√©marrage plus long que pr√©vu"
    docker-compose logs --tail=20
}

# Informations finales
display_final_info() {
    print_header "‚ú® OwnKube Install√© avec Succ√®s!"
    
    echo -e "${GREEN}‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó${NC}"
    echo -e "${GREEN}‚ïë     OwnKube by LAMJAR - Pr√™t √† l'emploi     ‚ïë${NC}"
    echo -e "${GREEN}‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù${NC}\n"
    
    echo -e "${CYAN}üìç R√©pertoire:${NC} $(pwd)"
    echo -e "${CYAN}üîó API Kubernetes:${NC} https://localhost:$API_PORT"
    echo -e "${CYAN}üåê HTTP/HTTPS:${NC} localhost:$HTTP_PORT / localhost:$HTTPS_PORT"
    
    echo -e "\n${YELLOW}Commandes rapides:${NC}"
    echo -e "  ${WHITE}./ownkube.sh start${NC}   - D√©marrer"
    echo -e "  ${WHITE}./ownkube.sh info${NC}    - Informations"
    echo -e "  ${WHITE}./ownkube.sh k get pods -A${NC} - Voir les pods"
    echo -e "  ${WHITE}./monitor.sh${NC}         - Monitoring"
    echo -e "  ${WHITE}./check-ports.sh${NC}     - V√©rifier les ports"
    
    echo -e "\n${GREEN}üéØ Test rapide:${NC}"
    echo -e "  ${WHITE}./ownkube.sh deploy examples/hello-world.yaml${NC}"
    
    echo -e "\n${MAGENTA}üí° Astuce:${NC} Ajoutez un alias dans ~/.bashrc:"
    echo -e "  ${WHITE}alias ok='$(pwd)/ownkube.sh'${NC}"
    
    if [ "$API_PORT" != "18443" ] || [ "$HTTP_PORT" != "18080" ]; then
        echo -e "\n${YELLOW}üìù Note:${NC} Les ports ont √©t√© ajust√©s automatiquement pour √©viter les conflits"
    fi
    
    echo -e "\n${GREEN}üöÄ OwnKube est pr√™t! Auto-Fix int√©gr√© pour une exp√©rience sans souci.${NC}\n"
}

# Fonction principale
main() {
    show_banner
    init_cache
    
    # V√©rifications
    check_prerequisites
    
    # Menu simplifi√©
    print_header "Mode d'Installation"
    echo "1) Installation Express (Recommand√©)"
    echo "2) Installation Personnalis√©e"
    echo "3) Quitter"
    echo ""
    read -rp "Choix [1]: " choice
    choice=${choice:-1}
    
    case $choice in
        1) configure_quick ;;
        2) configure_interactive ;;
        3) exit 0 ;;
        *) print_error "Choix invalide"; exit 1 ;;
    esac
    
    # Installation
    create_directory_structure
    create_docker_compose
    create_env_file
    create_utility_scripts
    create_example_manifest
    create_readme
    
    # Pr√©paration et d√©marrage
    pull_docker_images
    start_ownkube
    
    # Affichage final
    display_final_info
}

# Ex√©cution avec gestion d'erreur globale
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@" || {
        print_error "Installation √©chou√©e. V√©rifiez les logs ci-dessus."
        print_info "Essayez: docker-compose logs pour plus de d√©tails"
        exit 1
    }
fi